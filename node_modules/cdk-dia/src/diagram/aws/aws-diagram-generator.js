"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AwsDiagramGenerator = void 0;
const cdk_1 = require("../../cdk");
const __1 = require("..");
const customizable_attribute_1 = require("../component/customizable-attribute");
class AwsDiagramGenerator extends __1.DiagramGenerator {
    constructor(edgeResolver, iconSupplier) {
        super();
        this.edgeResolver = edgeResolver;
        this.iconSupplier = iconSupplier;
    }
    generate(cdkTree, collapse, includedStacks = false) {
        const diagram = new __1.Diagram();
        const cdkRoot = cdkTree.tree;
        diagram.root = this.generateComponentsTree(cdkRoot);
        if (includedStacks !== false)
            this.removeNonIncludedDiagrams(diagram, includedStacks);
        this.edgeResolver.resolveEdges(cdkRoot, diagram);
        if (collapse)
            this.collapseCdkConstructs(diagram.root);
        this.removeCdkAssets(diagram.root);
        diagram.root = this.collapseDoubleClusters(diagram.root);
        this.removeCrossStackEdges(diagram.root);
        this.removeSelfLinks(diagram.root);
        return diagram;
    }
    generateComponentsTree(cdkRoot) {
        const root = new __1.RootComponent(cdkRoot.id);
        cdkRoot.children.forEach((value) => {
            const component = this.generateSubTree(value, root);
            if (component != null && value.constructInfoFqn === undefined) {
                component.tags.set(__1.ComponentTags.isCdkStack, "true");
            }
            if (component != null) {
                root.addSubComponent(component);
            }
        });
        return root;
    }
    generateSubTree(cdkNode, parentComponent) {
        const component = this.generateComponent(cdkNode, parentComponent);
        if (component == null)
            return null;
        cdkNode.children.forEach((child) => {
            const childComponent = this.generateSubTree(child, component);
            if (childComponent != null)
                component.addSubComponent(childComponent);
        });
        return component;
    }
    generateComponent(cdkNode, parentComponent) {
        const { cfnType, label } = AwsDiagramGenerator.cfnProps(cdkNode);
        let component;
        if (cfnType != null) {
            component = this.generateCfnComponent(cdkNode, cfnType, label, parentComponent);
        }
        else {
            const relevantNode = cdkNode.findInSubTree(node => {
                return AwsDiagramGenerator.hasCfnProps(node);
            });
            if (relevantNode == null)
                return null;
            component = new __1.DiagramComponent(AwsDiagramGenerator.sanitizeComponentId(cdkNode.path), [cdkNode.id], parentComponent);
        }
        if (cdkNode.constructInfoFqn === cdk_1.ConstructInfoFqn.STACK) {
            component.tags.set(__1.ComponentTags.isCdkStack, "true");
        }
        if (cdkNode.constructInfoFqn === cdk_1.ConstructInfoFqn.STAGE) {
            component.tags.set(__1.ComponentTags.isCdkStage, "true");
        }
        this.applyAttributeSetCustomizers(cdkNode, component);
        return component;
    }
    removeNonIncludedDiagrams(diagram, includedStackIds) {
        const excludedStacks = [];
        const includedStacks = [];
        diagram.root.subTreeApplyAllComponents((component) => {
            const isStack = this.isStack(component);
            const idIncluded = this.idIncluded(includedStackIds, component);
            if (isStack) {
                if (!idIncluded) {
                    excludedStacks.push(component);
                }
                else {
                    includedStacks.push(component);
                }
            }
        });
        diagram.root.subTreeApplyAllComponents((component) => {
            const inExcludedStack = excludedStacks.find(excludedStack => component.isAncestor(excludedStack)) != null;
            const inIncludedStack = includedStacks.find(includedStack => component.isAncestor(includedStack)) != null;
            const isStack = this.isStack(component);
            const isIncludedStack = excludedStacks.includes(component);
            const containsIncludedStack = component.subTreeFindComponent(subComponent => {
                return this.isStack(subComponent) && this.idIncluded(includedStackIds, subComponent);
            });
            if ((inExcludedStack && !inIncludedStack && !containsIncludedStack) ||
                (isStack && !containsIncludedStack && isIncludedStack)) {
                component.destroyAndDetach();
            }
        });
    }
    isStack(component) {
        return component.tags.get(__1.ComponentTags.isCdkStack) == "true";
    }
    idIncluded(includedStacks, component) {
        return includedStacks.map(it => it.toLowerCase()).includes(component.id.toLowerCase());
    }
    applyAttributeSetCustomizers(tree, component) {
        tree.attributes.forEach((value, key) => {
            if (key.startsWith(cdk_1.CdkDia.attrPrefix)) {
                switch (key.substr(cdk_1.CdkDia.attrPrefix.length)) {
                    case customizable_attribute_1.CollapssingCustomizer.name:
                        customizable_attribute_1.CollapssingCustomizer.fromAttributeValue(value).customize(component);
                        break;
                    default:
                        throw new Error(`Unknown customizer ${key}`);
                }
            }
        });
    }
    generateCfnComponent(node, cfnType, cleanedResource, parent) {
        const component = new __1.DiagramComponent(AwsDiagramGenerator.sanitizeComponentId(node.path), AwsDiagramGenerator.cleanLabel([cleanedResource, node.id]), parent);
        const icon = this.iconSupplier.matchIcon(cfnType, node.attributes.get("aws:cdk:cloudformation:props"));
        if (icon !== null) {
            component.setIcon(icon);
        }
        else {
            component.label = [
                ...cfnType.split("::").slice(1).map(it => { return it.toUpperCase(); }),
                node.id
            ];
        }
        component.label = component.label.filter(it => { return it.toUpperCase() != "RESOURCE"; });
        return component;
    }
    static cfnProps(tree) {
        const cfnTypeAttr = tree.attributes.get("aws:cdk:cloudformation:type");
        if (cfnTypeAttr !== undefined) {
            return AwsDiagramGenerator.generateCfnProps(cfnTypeAttr);
        }
        if (tree.constructInfoFqn === cdk_1.ConstructInfoFqn.CUSTOM_RESOURCE) {
            return AwsDiagramGenerator.generateCfnProps("AWS::CloudFormation::CustomResource");
        }
        return { cfnType: null, label: null };
    }
    static generateCfnProps(cfnType) {
        const label = cfnType.split("::").slice(1).join(" ");
        return { cfnType: cfnType, label: label };
    }
    static hasCfnProps(node) {
        const { cfnType } = AwsDiagramGenerator.cfnProps(node);
        return cfnType != null || node.constructInfoFqn !== undefined;
    }
    collapseCdkConstructs(node) {
        const collapsingCustomization = node.tags.get(__1.ComponentTags.collapssingOverride);
        const forceCollapsed = collapsingCustomization === customizable_attribute_1.CollapseTypes.FORCE_COLLAPSE;
        const forceNonCollapsedRecursive = collapsingCustomization === customizable_attribute_1.CollapseTypes.FORCE_NON_COLLAPSE_RECURSIVE;
        const forceNonCollapsed = forceNonCollapsedRecursive || collapsingCustomization === customizable_attribute_1.CollapseTypes.FORCE_NON_COLLAPSE;
        if (forceCollapsed) {
            return this.collapseSubtreeToNode(node, node.subComponents()[0]);
        }
        const resourceComponent = Array.from(node.subComponents()).find(it => {
            const parts = it.idPathParts();
            return parts[parts.length - 1] == "Resource";
        });
        if (resourceComponent !== undefined && !forceNonCollapsed) {
            return this.collapseSubtreeToNode(node, resourceComponent);
        }
        else {
            if (!forceNonCollapsedRecursive) {
                node.subComponents().forEach(sub => {
                    this.collapseCdkConstructs(sub);
                });
            }
        }
    }
    collapseSubtreeToNode(parent, resource) {
        if (parent == null || resource == null)
            return;
        parent.icon = resource.icon;
        resource.collapseToParent();
        return resource;
    }
    removeCdkAssets(node) {
        node.subComponents().forEach(sub => {
            const subSubComponentIds = sub.subComponents().map(subSubComponent => { return subSubComponent.id; });
            if (subSubComponentIds.length == 3 &&
                subSubComponentIds.find(it => { return it.endsWith("S3Bucket"); }) !== undefined &&
                subSubComponentIds.find(it => { return it.endsWith("S3VersionKey"); }) !== undefined &&
                subSubComponentIds.find(it => { return it.endsWith("ArtifactHash"); }) !== undefined) {
                sub.removeAndDestroyAllSubComponents();
                node.removeSubComponent(sub);
            }
            else {
                this.removeCdkAssets(sub);
            }
        });
    }
    collapseDoubleClusters(root) {
        root.subComponents().forEach(component => {
            const newComponent = this.collapseDoubleClusters(component);
            if (component !== newComponent) {
                if (component.tags.get(__1.ComponentTags.isCdkStack) !== "true" &&
                    component.tags.get(__1.ComponentTags.isCdkStage) !== "true") {
                    root.replaceSubComponent(component, newComponent);
                }
            }
        });
        const components = root.subComponents();
        if (components.length == 1) {
            const single = components[0];
            return single;
        }
        return root;
    }
    removeCrossStackEdges(current) {
        if ((current instanceof __1.DiagramComponent) && current.tags.get(__1.ComponentTags.isCdkStack) == "true") {
            try {
                const stackRootComponent = current.treeAncestorWithTag(__1.ComponentTags.isCdkStack, "true");
                current.links.getLinkedComponents().forEach(linkedComponent => {
                    if (!stackRootComponent.componentIsInSubTree(linkedComponent)) {
                        current.links.removeLink(linkedComponent);
                        if (linkedComponent instanceof __1.DiagramComponent) {
                            stackRootComponent.links.addLink(linkedComponent.treeAncestorWithTag(__1.ComponentTags.isCdkStack, "true"));
                        }
                    }
                });
            }
            catch (e) {
                console.log("CrossStackEdges removal failed " + e);
            }
        }
        current.subComponents().forEach(sub => {
            this.removeCrossStackEdges(sub);
        });
    }
    removeSelfLinks(current) {
        current.links.getLinkedComponents().forEach(link => {
            if (link == current) {
                current.links.removeLink(link);
            }
        });
        current.subComponents().forEach(sub => { this.removeSelfLinks(sub); });
    }
}
exports.AwsDiagramGenerator = AwsDiagramGenerator;
AwsDiagramGenerator.sanitizeComponentId = (path) => path.replace(RegExp(":", "g"), "_");
AwsDiagramGenerator.cleanLabel = (label) => {
    if (label.length > 1 && label[label.length - 1] == "Resource")
        return label.slice(0, label.length - 1);
    return label;
};
//# sourceMappingURL=aws-diagram-generator.js.map