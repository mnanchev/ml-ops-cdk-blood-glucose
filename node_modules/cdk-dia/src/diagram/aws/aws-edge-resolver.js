"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AwsEdgeResolver = void 0;
const _ = __importStar(require("lodash"));
const uniqueid_1 = require("@aws-cdk/core/lib/private/uniqueid");
const component_1 = require("../component/component");
const aws_diagram_generator_1 = require("./aws-diagram-generator");
class AwsEdgeResolver {
    resolveEdges(tree, diagram) {
        this.addEdges(tree, diagram);
        tree.children.forEach(child => {
            this.resolveEdges(child, diagram);
        });
    }
    addEdges(node, diagram) {
        const originComponent = diagram.root.subTreeFindComponentById(aws_diagram_generator_1.AwsDiagramGenerator.sanitizeComponentId(node.path));
        if (originComponent == null) {
            return;
        }
        const edgeTargetStrings = this.edgeTargets(node);
        edgeTargetStrings.forEach(targetString => this.addEdge(targetString, originComponent));
    }
    addEdge(targetString, originComponent) {
        const cdkStackTree = originComponent.treeAncestorWithTag(component_1.ComponentTags.isCdkStack, "true");
        let targetComponent = this.findTargetComponent(cdkStackTree, targetString);
        if (targetComponent != null) {
            originComponent.links.addLink(targetComponent);
        }
    }
    findTargetComponent(cdkStackTree, targetString) {
        const perfectMatch = cdkStackTree.subTreeFindComponent((component) => {
            const uniqueResourceId = this.findUniqueResourceId(component);
            return targetString === uniqueResourceId;
        });
        if (perfectMatch != null)
            return perfectMatch;
        return cdkStackTree.subTreeFindComponent((component) => {
            const uniqueResourceId = this.findUniqueResourceId(component);
            return targetString.toLowerCase() === uniqueResourceId;
        });
    }
    findUniqueResourceId(component) {
        const stackDepth = component.treeAncestorWithTag(component_1.ComponentTags.isCdkStack, "true");
        const pathParts = component.idPathParts().slice(stackDepth.depth());
        if (pathParts.length === 0)
            return false;
        return uniqueid_1.makeUniqueId(pathParts);
    }
    edgeTargets(node) {
        const props = node.attributes.get("aws:cdk:cloudformation:props");
        if (props == undefined)
            return Array();
        const targets = Array.from(this.scrapePossibleEdgeTargets(props));
        return targets.map(path => aws_diagram_generator_1.AwsDiagramGenerator.sanitizeComponentId(path));
    }
    scrapePossibleEdgeTargets(object) {
        if (object === null || typeof object === "string")
            return new Set();
        const edgeTargets = new Set();
        for (const key in object) {
            if (key === "Fn::GetAtt" && object[key][0] !== undefined) {
                this.scrapeAllStrings(object[key]).forEach(it => {
                    edgeTargets.add(it);
                });
            }
            if (key === "Ref" && (typeof object[key] === "string")) {
                this.scrapeAllStrings(object[key]).forEach(it => {
                    edgeTargets.add(it);
                });
            }
            this.scrapePossibleEdgeTargets(object[key]).forEach(target => {
                edgeTargets.add(target);
            });
        }
        return edgeTargets;
    }
    scrapeAllStrings(object) {
        if (object === null || object === undefined) {
            return new Set();
        }
        if (typeof object === "string") {
            const set = new Set();
            set.add(object);
            return set;
        }
        if (Array.isArray(object)) {
            const array = object.map(it => {
                return Array.from(this.scrapeAllStrings(it));
            });
            const strings = _.flatten(array);
            return new Set(strings);
        }
        const edgeTargets = new Set();
        if (typeof object === "object") {
            for (const key in object) {
                if (key === "Fn::GetAtt" && object[key][0] !== undefined) {
                    edgeTargets.add(object[key][0]);
                }
                if (key === "Ref" && (typeof object[key] === "string")) {
                    edgeTargets.add(object[key]);
                }
                this.scrapePossibleEdgeTargets(object[key]).forEach(target => {
                    edgeTargets.add(target);
                });
            }
        }
        return edgeTargets;
    }
}
exports.AwsEdgeResolver = AwsEdgeResolver;
//# sourceMappingURL=aws-edge-resolver.js.map