"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Component = exports.ComponentTags = void 0;
const _ = __importStar(require("lodash"));
const component_links_1 = require("../component-links");
const link_1 = require("./link");
var ComponentTags;
(function (ComponentTags) {
    ComponentTags["isCdkStack"] = "isCdkStack";
    ComponentTags["isCdkStage"] = "isCdkStage";
    ComponentTags["collapssingOverride"] = "collapssingOverride";
})(ComponentTags = exports.ComponentTags || (exports.ComponentTags = {}));
class Component {
    constructor(id) {
        this.idPathParts = () => this.id.split("/");
        this.icon = null;
        this.tags = new Map();
        this._subComponents = new Set();
        this._links = new component_links_1.ComponentLinks(this);
        this.setId(id);
    }
    get id() {
        return this._id;
    }
    setId(value) {
        this._id = value;
    }
    subComponents() {
        return Array.from(this._subComponents);
    }
    removeSubComponent(component) {
        component.destroyLinks();
        this._subComponents.delete(component);
    }
    addSubComponent(component) {
        this.assureIdDoesNotExistInConnectedComponents(component.id);
        this._subComponents.add(component);
    }
    removeAndDestroyAllSubComponents() {
        this._subComponents.forEach(subComponent => {
            this.removeAndDestroyAllSubComponentsRec(subComponent);
        });
        this._subComponents = new Set();
    }
    replaceSubComponent(component, newComponent) {
        const reverseLinkingComponents = component.links.getReverseLinkedComponents();
        reverseLinkingComponents.forEach(revLinking => {
            if (revLinking !== newComponent) {
                revLinking.links.updateLinkTarget(component, newComponent);
            }
        });
        const linkedComponents = component.links.getLinkedComponents();
        linkedComponents.forEach(link => {
            if (link !== newComponent) {
                newComponent.links.addLink(link);
            }
        });
        this.removeSubComponent(component);
        this.addSubComponent(newComponent);
    }
    removeAndDestroyAllSubComponentsRec(node) {
        node._subComponents.forEach(subComponent => {
            this.removeAndDestroyAllSubComponentsRec(subComponent);
        });
        node.destroyLinks();
    }
    destroyAndDetach() {
        this.parent().removeSubComponent(this);
    }
    collapseToParent() {
        const subtreeReverseEdges = this.parent().subTreeReverseLinks();
        subtreeReverseEdges.forEach(edge => {
            if (!this.parent().componentIsInSubTree(edge.from)) {
                edge.from.links.updateLinkTarget(edge.to, this.parent());
            }
        });
        const linksToSubTree = this.parent().links.getLinkedComponents();
        linksToSubTree.forEach(edge => {
            if (this.parent().componentIsInSubTree(edge))
                this.parent().links.removeLink(edge);
        });
        const subtreeEdges = this.parent().subTreeLinks();
        subtreeEdges.forEach(edge => {
            if (!this.parent().componentIsInSubTree(edge.to))
                edge.from.links.removeLink(edge.to);
            this.parent().links.addLink(edge.to);
        });
        this.parent().removeAndDestroyAllSubComponents();
    }
    subTreeComponentIds() {
        const allIds = new Set();
        this.subTreeComponents().forEach(it => { allIds.add(it.id); });
        return allIds;
    }
    componentIsInSubTree(search) {
        const components = this.subTreeComponents();
        const component = components.find(it => {
            return it.id === search.id;
        });
        return (component !== undefined);
    }
    subTreeApplyAllComponents(lambda) {
        this.applyAllComponentsRec(this, lambda);
    }
    applyAllComponentsRec(subTree, lambda) {
        lambda(subTree);
        subTree.subComponents().forEach(sub => this.applyAllComponentsRec(sub, lambda));
    }
    subTreeFindComponentById(id) {
        return this.subTreeFindComponent(component => {
            return component.id == id;
        });
    }
    subTreeFindComponent(predicate) {
        return this.subTreeFindComponentRec(this, predicate);
    }
    subTreeFindComponentRec(subTree, predicate) {
        if (predicate(subTree))
            return subTree;
        return subTree.subComponents().map(it => {
            return it.subTreeFindComponent(predicate);
        }).find(it => {
            return it != null;
        });
    }
    subTreeComponents() {
        const components = _.flatten(this.subComponents().map(sub => {
            return sub.subTreeComponents();
        }));
        return components.concat([this]);
    }
    get links() {
        return this._links;
    }
    subTreeReverseLinks(withSelf = true) {
        return this.subTreeReverseLinksRec(this, withSelf);
    }
    subTreeReverseLinksRec(current, includeSelf = true) {
        const targets = [];
        if (includeSelf) {
            targets.push(...current.links.getReverseLinkedComponents().map(component => new link_1.Link(component, current)));
        }
        current.subComponents().forEach(sub => {
            targets.push(...(this.subTreeReverseLinksRec(sub)));
        });
        return targets;
    }
    subTreeLinks() {
        return this.subTreeLinksRec(this);
    }
    subTreeLinksRec(current) {
        const targets = current.links.getLinkedComponents().map(component => new link_1.Link(current, component));
        current.subComponents().forEach(sub => {
            targets.push(...(this.subTreeLinksRec(sub)));
        });
        return targets;
    }
    treeAncestorWithTag(tagKey, tagVal) {
        if (this.tags.get(tagKey) === tagVal)
            return this;
        return this.parent().treeAncestorWithTag(tagKey, tagVal);
    }
    isAncestor(possibleAncestor) {
        try {
            return this.parent() == possibleAncestor || this.parent().isAncestor(possibleAncestor);
        }
        catch (e) {
            return false;
        }
    }
}
exports.Component = Component;
//# sourceMappingURL=component.js.map